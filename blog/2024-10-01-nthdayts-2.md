---
slug: nthday-ts-2
title: TS Challenge Day 2 - Pick
tags: [ts-challenge]
---

For Day 2 of the TS Challenge - We're gonna implement the `Pick` utility type from scratch.

Implement the built-in `Pick<T, K>` generic without using it.
Constructs a type by picking the set of properties `K` from `T`
For example:

```ts
interface Todo {
  title: string;
  description: string;
  completed: boolean;
}

type TodoPreview = MyPick<Todo, "title" | "completed">;

const todo: TodoPreview = {
  title: "Clean room",
  completed: false,
};
```

<!-- truncate -->

Solution:

```ts
type MyPick<T, K extends keyof T> = [K] extends [keyof T]
  ? { [Key in K]: T[Key] }
  : never;
```

Breaking the stereo-type:

1. Generic type `type MyPick<T, K extends keyof T>`
2. Checking the condition `[K] extends [keyof T] ? { [Key in K]: T[Key] } ? never`

## Generic Type

```ts
type MyPick<T, K extends keyof T>
```

The type `T` in the generic represents in the expected incoming object type.
Meanwhile, the type `K` tells us that it possibly extends `keyof T`. In this case, `keyof T` is a string literal type that represents keys of an object from type passed as the first argument represented by `T`.

```ts
// this won't work as the keys shape and number are not in the first object.
type TestPick = MyPick<
  { shape: "square"; animal: "dog"; color: "green" },
  "shape" | "number"
>;

// this will work as the keys animal and color are in the first object.
type TestPick = MyPick<
  { shape: "square"; animal: "dog"; color: "green" },
  "animal" | "color"
>;
```

## Condition

```ts
[K] extends [keyof T] ? { [Key in K]: T[Key] } ? never
```

Before we understand the condition, we need to understand the return type if the condition is met represented by `{ [Key in K]: T[Key] }` .
This means that we are constructing an object type where the `Key in K` means looping over a list of keys in type `K`. This concept is called mapped types.

Meanwhile, `T[Key]` simply means using the concept of indexed type where we are accessing the "object value" from type `T` based on the type `Key`. This concept is similar to how we access values in a normal object using a bracket notation.

If the condition is met where `K extends keyof T` it should produce a type like:

```ts
// K extends keyof T ? { [Key in K]: T[Key] } : never;

type TestPick = MyPick<
	{ shape: "square", animal: "dog", color: "green" },
	"animal" | "color"

// type TestPick =  { "animal": "dog"} | { "color": "green" }
```

However, this is not the result we want. We don't want a union of objects.
By default, the conditional types result to a distributed form when working with generic types but we don't want to make it distribute. This where the brackets come in. Adding the brackets disables this behaviour and results to one object.

```ts
// [K] extends [keyof T] ? { [Key in K]: T[Key] } : never;

type TestPick = MyPick<
	{ shape: "square", animal: "dog", color: "green" },
	"animal" | "color"

// type TestPick =  { "animal": "dog", "color": "green" }
```
